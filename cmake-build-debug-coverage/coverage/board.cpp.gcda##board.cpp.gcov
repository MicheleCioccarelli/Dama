        -:    0:Source:/home/sedano/CLionProjects/Dama/board/board.cpp
        -:    0:Graph:/home/sedano/CLionProjects/Dama/cmake-build-debug-coverage/CMakeFiles/MakeDamaGreatAgain.dir/board/board.cpp.gcno
        -:    0:Data:/home/sedano/CLionProjects/Dama/cmake-build-debug-coverage/CMakeFiles/MakeDamaGreatAgain.dir/board/board.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "board.h"
        -:    2:
        1:    3:Board::Board() {
        -:    4:    // Initialize vector
        1:    5:    matrix.resize(rows);
        -:    6:
        -:    7:    // Give color and coords to every square
        9:    8:    for (int row = 0; row < rows; row++) {
       72:    9:        for (int col = 0; col < columns; col++) {
       64:   10:            Coords currentCoords = Coords((ColumnNotation) col, row);
       64:   11:            if ((col + row) % 2 == 0) {
       32:   12:                matrix[row].emplace_back(currentCoords, NERA);
        -:   13:            } else {
       32:   14:                matrix[row].emplace_back(currentCoords, BIANCA);
        -:   15:            }
        -:   16:        }
        -:   17:    }
        1:   18:}
        -:   19:
        -:   20:// ======= PIECE INITIALIZATION =======
        2:   21:void Board::standard_game_initialization() {
        -:   22:    // Initialize pieces
       18:   23:    for (int row = 0; row < rows; row++) {
      144:   24:        for (int col = 0; col < columns; col++) {
      128:   25:            if (row < 3 && matrix[row][col].color == NERA) {
       24:   26:                matrix[row][col].set_piece(DAMA_B);
      104:   27:            } else if (row >= (columns - 3) && matrix[row][col].color == NERA) {
       24:   28:                matrix[row][col].set_piece(DAMA_N);
        -:   29:            }
        -:   30:        }
        -:   31:    }
        2:   32:}
        -:   33:
    #####:   34:void Board::colored_game_initialization() {
    #####:   35:    for (int row = 0; row < rows; row++) {
    #####:   36:        for (int col = 0; col < columns; col++) {
    #####:   37:            if (matrix[row][col].color == NERA) {
    #####:   38:                matrix[row][col].piece = COLORATA;
        -:   39:            }
        -:   40:        }
        -:   41:    }
    #####:   42:}
        -:   43:
    #####:   44:void Board::damone_game_initialization() {
        -:   45:    // Initialize pieces
    #####:   46:    for (int row = 0; row < rows; row++) {
    #####:   47:        for (int col = 0; col < columns; col++) {
    #####:   48:            if (row < 3 && matrix[row][col].color == NERA) {
    #####:   49:                matrix[row][col].set_piece(DAMONE_B);
    #####:   50:            } else if (row >= (columns - 3) && matrix[row][col].color == NERA) {
    #####:   51:                matrix[row][col].set_piece(DAMONE_N);
        -:   52:            }
        -:   53:        }
        -:   54:    }
    #####:   55:}
        -:   56:
    #####:   57:void Board::empty_game_initialization() {
    #####:   58:    for (int row = 0; row < rows; row++) {
    #####:   59:        for (int col = 0; col < columns; col++) {
    #####:   60:            if (row < 3 && matrix[row][col].color == NERA) {
    #####:   61:                matrix[row][col].set_piece(VUOTA);
    #####:   62:            } else if (row >= (columns - 3) && matrix[row][col].color == NERA) {
    #####:   63:                matrix[row][col].set_piece(VUOTA);
        -:   64:            }
        -:   65:        }
        -:   66:    }
    #####:   67:}
        -:   68:
        -:   69:// ====== MOVE EXECUTION ======
    #####:   70:void Board::execute_move(Move move) {
    #####:   71:    Square endingSquare = matrix[move.coords.at(1).row - 1][move.coords.at(1).column];
    #####:   72:    Square startingSquare = matrix[move.coords.at(0).row - 1][move.coords.at(0).column];
    #####:   73:    int lastIndex = move.coords.size() - 1;
        -:   74:
    #####:   75:    if (move.type == MOVE) {
    #####:   76:        endingSquare.piece = startingSquare.piece;
    #####:   77:        startingSquare.piece = VUOTA;
        -:   78:
    #####:   79:        matrix[move.coords.at(1).row - 1][move.coords.at(1).column]= endingSquare;
    #####:   80:        matrix[move.coords.at(0).row - 1][move.coords.at(0).column] = startingSquare;
    #####:   81:    } else if (move.type == EAT) {
    #####:   82:        startingSquare = matrix[move.coords[0].row - 1][move.coords[0].column];
    #####:   83:        endingSquare = matrix[move.coords.at(lastIndex).row - 1][move.coords.at(lastIndex).column];
        -:   84:        // Eat all the target pieces
    #####:   85:        for (int i = 1; i < lastIndex; i++) {
    #####:   86:            matrix[move.coords.at(i).row - 1][move.coords.at(i).column].piece = VUOTA;
        -:   87:        }
        -:   88:        // Move the starting square's piece and null the first square out
    #####:   89:        endingSquare.piece = startingSquare.piece;
    #####:   90:        startingSquare.piece = VUOTA;
        -:   91:
    #####:   92:        matrix[move.coords[0].row - 1][move.coords[0].column].piece = startingSquare.piece;
    #####:   93:        matrix[move.coords.at(lastIndex).row - 1][move.coords.at(lastIndex).column].piece
    #####:   94:            = endingSquare.piece;
        -:   95:    }
    #####:   96:}
        -:   97:
    #####:   98:void Board::blow_up(Coords blownCoord, Move& move) {
    #####:   99:    move.blownCoord = blownCoord;
    #####:  100:    edit(Coords(blownCoord.column, blownCoord.row), VUOTA);
    #####:  101:}
        -:  102:
        1:  103:void Board::edit(Coords coords, Piece _piece) {
        1:  104:    matrix[coords.row - 1][coords.column].piece = _piece;
        1:  105:}
