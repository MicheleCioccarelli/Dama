        -:    0:Source:/home/sedano/CLionProjects/Dama/engine/engine.cpp
        -:    0:Graph:/home/sedano/CLionProjects/Dama/cmake-build-debug-coverage/CMakeFiles/MakeDamaGreatAgain.dir/engine/engine.cpp.gcno
        -:    0:Data:/home/sedano/CLionProjects/Dama/cmake-build-debug-coverage/CMakeFiles/MakeDamaGreatAgain.dir/engine/engine.cpp.gcda
        -:    0:Runs:1
        -:    1:#include "engine.h"
        -:    2:
        -:    3:// ====== GAME ENGINE ======
        1:    4:GameEngine::GameEngine(GameStyle gameStyle, BoardTokens _tokens, SetPieces _pieces, BoardCoords _coords)
        1:    5:        : render(_tokens, _pieces, _coords) {
        1:    6:    switch (gameStyle) {
        1:    7:        case STANDARD:
        1:    8:            board.standard_game_initialization();
        1:    9:            break;
    #####:   10:        case DAMONI:
    #####:   11:            board.damone_game_initialization();
    #####:   12:            break;
    #####:   13:        case COLORED:
    #####:   14:            board.colored_game_initialization();
    #####:   15:            break;
        -:   16:    }
        1:   17:}
        -:   18:
        2:   19:Coords GameEngine::convert_coords(Coords coords) {
        2:   20:    return Coords(coords.column, coords.row - 1);
        -:   21:}
        -:   22:
    #####:   23:void GameEngine::dispatch_move(const Move& move) {
        -:   24:    // Add the move to the respective player
    #####:   25:    if (move.color == BIANCO) {
    #####:   26:        whitePlayer.add_move(move);
    #####:   27:    } else if (move.color == NERO) {
    #####:   28:        blackPlayer.add_move(move);
        -:   29:    }
        -:   30:
    #####:   31:    board.execute_move(move);
    #####:   32:}
        -:   33:
    #####:   34:MoveReturn GameEngine::validate_move(Move &move) {
        -:   35:    Piece startingPiece;
        -:   36:    Piece endingPiece;
    #####:   37:    Square endingSquare(Coords(Z, 10), NERA);
    #####:   38:    Square startingSquare(Coords(Z, 10), NERA);
    #####:   39:    int lastIndex = move.coords.size() - 1;
        -:   40:    int horizontalDistance;
        -:   41:    int verticalDistance;
        -:   42:
    #####:   43:    Coords startingCoords = convert_coords(move.coords[0]);
    #####:   44:    Coords endingCoords = convert_coords(move.coords[lastIndex]);
        -:   45:
    #####:   46:    startingPiece = board.matrix[startingCoords.row][startingCoords.column].piece;
    #####:   47:    endingPiece = board.matrix[endingCoords.row][endingCoords.column].piece;
    #####:   48:    endingSquare = board.matrix[endingCoords.row][endingCoords.column];
    #####:   49:    startingSquare = board.matrix[startingCoords.row][startingCoords.column];
        -:   50:
        -:   51:    // Distance between the starting square and the ening square
    #####:   52:    verticalDistance = startingSquare.coords.row - endingSquare.coords.row;
    #####:   53:    horizontalDistance = startingSquare.coords.column - endingSquare.coords.column;
        -:   54:
        -:   55:    // Check if ou arre actually moving a piece, not just air
    #####:   56:    if (startingPiece == VUOTA) {
    #####:   57:        return EMPTY_START;
        -:   58:    }
        -:   59:
        -:   60:    // Check if you are going in a black square
    #####:   61:    if (endingSquare.color != NERA) {
    #####:   62:        return WHITE_SQUARE;
        -:   63:    }
        -:   64:
        -:   65:    // Check if you are moving by one square
    #####:   66:    if (verticalDistance == 1 || verticalDistance == -1) {
    #####:   67:        if (horizontalDistance == 1 || horizontalDistance == -1) {
        -:   68:            // Check if a damina is moving forwards
    #####:   69:            if (startingPiece == DAMA_B && verticalDistance == 1 ||
    #####:   70:                startingPiece == DAMA_N && verticalDistance == -1) {
    #####:   71:                return BEHIND;
        -:   72:            }
    #####:   73:            if (endingPiece != VUOTA) {
    #####:   74:                return POPULATED;
        -:   75:            }
    #####:   76:            return VALID;
        -:   77:        }
        -:   78:    }
    #####:   79:    return TOO_FAR;
        -:   80:}
        -:   81:
        1:   82:MoveReturn GameEngine::check_eat(Move& move) {
        1:   83:    if (move.type == MOVE) {
    #####:   84:        return INVALID;
        -:   85:    }
        -:   86:
        1:   87:    MoveReturn returnValue = UNDEFINED;
        1:   88:    Square endingSquare(Coords(Z, 9), NERA);
        1:   89:    Square startingSquare(Coords(Z, 9), NERA);
        1:   90:    Square forwardSquare(Coords(Z, 9), NERA);
        -:   91:    int verticalDistance;
        -:   92:    int horizontalDistance;
        -:   93:
        1:   94:    Coords startingCoords;
        1:   95:    Coords endingCoords;
        -:   96:
        1:   97:    Piece startingPiece = board.matrix[move.coords.at(0).row - 1][move.coords.at(0).column].piece;
       1*:   98:    for (int i = 1; i < move.coords.size(); i++) {
        1:   99:        if (i == 1) {
        1:  100:            startingCoords = convert_coords(move.coords[0]);
        1:  101:            endingCoords = convert_coords(move.coords[1]);
        -:  102:
        1:  103:            endingSquare = board.matrix[endingCoords.row][endingCoords.column];
        1:  104:            startingSquare = board.matrix[startingCoords.row][startingCoords.column];
        -:  105:
        1:  106:            verticalDistance = startingSquare.coords.row - endingSquare.coords.row;
        1:  107:            horizontalDistance = startingSquare.coords.column - endingSquare.coords.column;
        -:  108:
        1:  109:            forwardSquare = board.matrix[endingSquare.coords.row - verticalDistance]
        1:  110:                    [endingSquare.coords.column - horizontalDistance];
        -:  111:            // Check piece compatibility
        1:  112:            if (startingSquare.piece == endingSquare.piece) {
        1:  113:                return CANNIBALISM;
    #####:  114:            } else if (startingSquare.piece == DAMA_B && endingSquare.piece == DAMONE_N) {
    #####:  115:                return TOO_BIG;
    #####:  116:            } else if (startingSquare.piece == DAMA_N && endingSquare.piece == DAMONE_B) {
    #####:  117:                return TOO_BIG;
    #####:  118:            } else if (startingSquare.piece == DAMA_B && endingSquare.piece == DAMONE_B) {
    #####:  119:                return FRIENDLY_FIRE;
    #####:  120:            } else if (startingSquare.piece == DAMA_N && endingSquare.piece == DAMONE_N) {
    #####:  121:                return FRIENDLY_FIRE;
    #####:  122:            } else if (startingSquare.piece == DAMONE_B && endingSquare.piece == DAMA_B) {
    #####:  123:                return FRIENDLY_FIRE;
    #####:  124:            } else if (startingSquare.piece == DAMONE_N && endingSquare.piece == DAMA_N) {
    #####:  125:                return FRIENDLY_FIRE;
        -:  126:            }
        -:  127:
        -:  128:            // Create a temporary move to check
    #####:  129:            Move moveToValidate(move.color, move.type);
    #####:  130:            moveToValidate.add_coords(move.coords[0]);
    #####:  131:            moveToValidate.add_coords(move.coords[1]);
        -:  132:
    #####:  133:            if (validate_move(moveToValidate) == POPULATED) {
        -:  134:                // Check if there is an empty space behind the targeted square
    #####:  135:                if (forwardSquare.piece == VUOTA) {
    #####:  136:                    returnValue = VALID;
        -:  137:                }
        -:  138:            } else {
        -:  139:                // The targeted square doesn't have anything on it
    #####:  140:                return EMPTY_TARGET;
        -:  141:            }
    #####:  142:        } else if (returnValue == VALID) {
        -:  143:            /*
        -:  144:            if (move.coords.at(i).row - 1 <= 0 || move.coords.at(i).row - 1 >= 7) {
        -:  145:                return OUT_OF_BOUNDS;
        -:  146:            } else if (move.coords.at(i).column < 1 || move.coords.at(i).column >= 8) {
        -:  147:                return OUT_OF_BOUNDS;
        -:  148:            }*/
    #####:  149:            endingCoords = convert_coords(move.coords[i]);
        -:  150:
    #####:  151:            endingSquare = board.matrix[endingCoords.row][endingCoords.column];
    #####:  152:            startingSquare = forwardSquare;
    #####:  153:            startingSquare.piece = startingPiece;
        -:  154:
    #####:  155:            verticalDistance = startingSquare.coords.row - endingSquare.coords.row;
    #####:  156:            horizontalDistance = startingSquare.coords.column - endingSquare.coords.column;
    #####:  157:            forwardSquare = board.matrix[endingSquare.coords.row - verticalDistance]
    #####:  158:                    [endingSquare.coords.column - horizontalDistance];
        -:  159:
        -:  160:            // Check piece compatibility
    #####:  161:            if (startingSquare.piece == endingSquare.piece) {
    #####:  162:                return CANNIBALISM;
    #####:  163:            } else if (startingSquare.piece == DAMA_B && endingSquare.piece == DAMONE_N) {
    #####:  164:                return TOO_BIG;
    #####:  165:            } else if (startingSquare.piece == DAMA_N && endingSquare.piece == DAMONE_B) {
    #####:  166:                return TOO_BIG;
    #####:  167:            } else if (startingSquare.piece == DAMA_B && endingSquare.piece == DAMONE_B) {
    #####:  168:                return FRIENDLY_FIRE;
    #####:  169:            } else if (startingSquare.piece == DAMA_N && endingSquare.piece == DAMONE_N) {
    #####:  170:                return FRIENDLY_FIRE;
        -:  171:            }
        -:  172:
    #####:  173:            Move moveToValidate(move.color, move.type);
    #####:  174:            board.matrix[startingSquare.coords.row][startingSquare.coords.column].piece =
    #####:  175:                    board.matrix[move.coords[0].row][move.coords[0].column].piece;
    #####:  176:            moveToValidate.add_coords(startingSquare.coords);
        -:  177:            // Square to eat
    #####:  178:            moveToValidate.add_coords(move.coords[i]);
        -:  179:
    #####:  180:            if (validate_move((Move&) moveToValidate) == POPULATED) {
        -:  181:                // Check if there is an empty space behind the targeted square
    #####:  182:                if (forwardSquare.piece == VUOTA) {
    #####:  183:                    board.matrix[startingSquare.coords.row][startingSquare.coords.column].piece = VUOTA;
    #####:  184:                    returnValue = VALID;
        -:  185:                }
        -:  186:            } else {
        -:  187:                // The targeted square doesn't have anythin on it
    #####:  188:                return EMPTY_TARGET;
        -:  189:            }
    #####:  190:        } if (returnValue == UNDEFINED) {
    #####:  191:            return returnValue;
        -:  192:        }
        -:  193:    }
        -:  194:
    #####:  195:    board.matrix[startingSquare.coords.row][startingSquare.coords.column].piece = startingPiece;
    #####:  196:    move.coords.emplace_back(Coords(forwardSquare.coords.column, forwardSquare.coords.row + 1));
    #####:  197:    return returnValue;
        -:  198:}
        -:  199:
        -:  200:// You give 2 coords, then you construct a trasparent move with those coords and you check it
    #####:  201:MoveReturn GameEngine::check_blow(Coords _startingCoords, Coords _endingCoords) {
    #####:  202:    Move move = Move(_startingCoords, _endingCoords);
    #####:  203:    Square endingSquare = board.matrix[move.coords.at(1).row - 1][move.coords.at(1).column];
    #####:  204:    Square startingSquare = board.matrix[move.coords.at(0).row - 1][move.coords.at(0).column];
        -:  205:
    #####:  206:    if (startingSquare.piece == DAMONE_B && endingSquare.piece == DAMA_N) {
    #####:  207:        return ROCK_SOLID;
    #####:  208:    } else if (startingSquare.piece == DAMONE_N && endingSquare.piece == DAMA_B) {
    #####:  209:        return ROCK_SOLID;
        -:  210:    }
        -:  211:    // Check if the move is blowable
    #####:  212:    if (check_eat((Move&) move) == VALID) {
    #####:  213:        return BLOWABLE;
        -:  214:    }
    #####:  215:    return ROCK_SOLID;
        -:  216:}
        -:  217:
    #####:  218:int GameEngine::count_pieces(PlayerColor pColor) {
    #####:  219:    int returnValue = 0;
    #####:  220:    for (int row = 0; row < rows; row++) {
    #####:  221:        for (int col = 0; col < columns; col++) {
    #####:  222:            if (pColor == BIANCO) {
    #####:  223:                if (board.matrix[row][col].piece == DAMA_B || board.matrix[row][col].piece == DAMONE_B)
    #####:  224:                    returnValue++;
    #####:  225:            } else if (pColor == NERO) {
    #####:  226:                if (board.matrix[row][col].piece == DAMA_N || board.matrix[row][col].piece == DAMONE_N)
    #####:  227:                    returnValue++;
        -:  228:            }
        -:  229:        }
        -:  230:    }
    #####:  231:    return returnValue;
        -:  232:}
        -:  233:
    #####:  234:MoveReturn GameEngine::submit(const Move& move) {
        -:  235:    MoveReturn status;
        -:  236:
    #####:  237:    switch (move.type) {
    #####:  238:        case MOVE:
    #####:  239:            status = validate_move((Move&) move);
    #####:  240:            break;
    #####:  241:        case EAT:
    #####:  242:            status = check_eat((Move&) move);
    #####:  243:            break;
        -:  244:    }
        -:  245:
    #####:  246:    if (status == VALID) {
    #####:  247:        dispatch_move(move);
        -:  248:    }
    #####:  249:    return status;
        -:  250:}
        -:  251:
    #####:  252:void GameEngine::promote() {
    #####:  253:    for (int row = 0; row <= rows; row += 7) {
    #####:  254:        for (int col = 0; col < columns; col++) {
    #####:  255:            if (board.matrix[row][col].piece == DAMA_N && row == 0) {
    #####:  256:                board.matrix[row][col].piece = DAMONE_N;
    #####:  257:            } else if (row == 7 && board.matrix[row][col].piece == DAMA_B) {
    #####:  258:                board.matrix[row][col].piece = DAMONE_B;
        -:  259:            }
        -:  260:        }
        -:  261:    }
    #####:  262:}
